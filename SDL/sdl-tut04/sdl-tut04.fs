\ ===[ Code Addendum 01 ]============================================
\             gforth: SDL/OpenGL Graphics Part IV
\ ===================================================================
\    File Name: sdl-primitives.fs
\       Author: Timothy Trussell
\         Date: 02/22/2010
\  Description: SDL Primitives
\ Forth System: gforth-0.7.0
\ Linux System: Ubuntu v9.10 i386, kernel 2.6.31-19
\ C++ Compiler: gcc (Ubuntu 4.4.1-4ubuntu9) 4.4.1
\ ===================================================================

\ ---[ Prototypes ]--------------------------------------------------

\ : <PlotPixel>                 { *ofs _pixel _bytepp -- }
\ : PutPixel                    { *dst _x _y _pixel -- }
\ : Line                        { *dst _x1 _y1 _x2 _y2 _pixel -- }\ : VLine                       { *dst _x _y1 _y2 _pixel -- }
\ : VLine1                      { *dst _x _y1 _y2 _pixel -- }
\ : HLine                       { *dst _x1 _x2 _y _pixel -- }
\ : HLine1                      { *dst _x1 _x2 _y _pixel -- }
\ : <Draw-Image>                { *dst _x _y _w _h *src tflag -- }
\ : PutImage                    ( *dst _x _y _w _h *src -- )
\ : PutSprite                   ( *dst _x _y _w _h *src -- )

\ ------------------------------------------------[End Prototypes]---

\ ---[ <PlotPixel> ]-------------------------------------------------
\ Pixel plot function
\
\   *ofs    - target address of pixel in destination surface
\             Calculated by:
\               ofs = *dst+(y*swidth)+(x*bytepp)
\             where
\               *dst   - pointer to destination surface
\               x,y    - coordinates to plot the pixel to
\               swidth - width of screen line for this color depth
\               bytepp - # of bytes per pixel for this color depth
\
\   _pixel  - the pixel data to be plotted
\   _bytepp - number of bytes per pixel on the surface
\
\ Called from PutPixel, VLine, HLine
\
\ Note-
\       C! stores an 8-bit value to the destination address
\       w! stores a 16-bit value to the destination address
\       !  stores a 32-bit value to the destination address

: <PlotPixel> { *ofs _pixel _bytepp -- }
  _bytepp case
    1 of _pixel *ofs C! endof
    2 of _pixel *ofs w! endof
    3 of SDL_BYTEORDER SDL_BIG_ENDIAN = if
           _pixel 16 RSHIFT *ofs C!
           _pixel 8 RSHIFT *ofs 1+ C!
           _pixel *ofs 2 + C!
         else
           _pixel *ofs C!
           _pixel 8 RSHIFT *ofs 1+ C!
           _pixel 16 RSHIFT *ofs 2 + C!
         then
      endof
    4 of _pixel *ofs ! endof
  endcase
;

\ ---[ PutPixel ]----------------------------------------------------
\ Plots the pixel value to the *dst surface at the given coordinates.

\ PutPixel accesses the <pitch> and <pixel> fields of the sdl-surface
\ struct, which is defined in the sdl.fs file.

\ <pitch> defines the window-width of the surface, and represents the
\ actual number of bytes each line contains.
\
\   In 1024x768x8  mode, this value is 1024, with 1 byte/pixel
\   In 1024x768x16 mode, this value is 2048, with 2 bytes/pixel
\   In 1024x768x24 mode, this value is 3072, with 3 bytes/pixel
\   In 1024x768x32 mode, this value is 4096, with 4 bytes/pixel
\
\ <pixel> is a pointer to the actual memory for the surface data

\ Note that the window-width <pitch> represents is generated by the
\ SDL video subsystem, not by the call to InitGraph which we make to
\ create a display window.

\ The address is calculated with the following formula:
\               ofs = *dst+(y*swidth)+(x*bytepp)
\ where
\               *dst   - pointer to destination surface
\               x,y    - coordinates to plot the pixel to
\               swidth - <pitch> value of the screen line, defined as
\                        window-screenw * bytes-per-pixel
\               bytepp - # of bytes per pixel for this color depth
\

: PutPixel { *dst _x _y _pixel -- }
  \ Lock the surface if required
  *dst sdl-mustlock if
    *dst sdl-locksurface drop
  then
  \ Calculate the target address of the pixel
  *dst sdl-surface-pixels @     \ *pixels              32-bit pointer
  *dst sdl-surface-pitch sw@    \ *pixels swidth         16-bit value
  _y * +                        \ *pixels[swidth*y]
  *dst sdl-surface-format @     \ *pixels[swidth*y] *format
  sdl-pixelformat-bytesperpixel \ *pixels[swidth*y] *format->bytepp
  C@                            \ *pixels[swidth*y] bytepp
  dup >R                        \ *pixels[swidth*y] bytepp
  _x * +                        \ *pixels[ofs]
  _pixel                        \ *pixels[ofs] pixel
  R>                            \ *pixels[ofs] pixel bytepp
  <PlotPixel>                   \ --
  \ Now unlock the surface if required
  *dst sdl-mustlock if
    *dst sdl-unlocksurface
  then
;
\     ------
\ ---[ Line ]--------------------------------------------------------
\     ------
\ Draws a Bresenham line from x1,y1 to x2,y2 in the color pixel.

0 value [[d]
0 value [[x]
0 value [[y]
0 value [[ax]
0 value [[ay]
0 value [[sx]
0 value [[sy]
0 value [[dx]
0 value [[dy]

: Line { *dst _x1 _y1 _x2 _y2 _pixel -- }
  _x2 _x1 - to [[dx]
  [[dx] abs 2* to [[ax]
  [[dx] 0< if -1 else 1 then to [[sx]

  _y2 _y1 - to [[dy]
  [[dy] abs 2* to [[ay]
  [[dy] 0< if -1 else 1 then to [[sy]

  _x1 to [[x]
  _y1 to [[y]

  [[ax] [[ay] > if
    [[ay] [[ax] 2/ - to [[d]
    begin
      [[x] _x2 = 0=                                \ while [[x] != x2
    while
      *dst [[x] [[y] _pixel PutPixel
      [[d] 0 >= if
        [[sy] [[y] + to [[y]
        [[ax] negate [[d] + to [[d]
      then
      [[sx] [[x] + to [[x]
      [[ay] [[d] + to [[d]
    repeat
  else                                                  \ ax not > ay
    [[ax] [[ay] 2/ - to [[d]
    begin
      [[y] _y2 = 0=                                \ while [[y] != y2
    while
      *dst [[x] [[y] _pixel PutPixel
      [[d] 0 >= if
        [[sx] [[x] + to [[x]
        [[ay] negate [[d] + to [[d]
      then
      [[sy] [[y] + to [[y]
      [[ax] [[d] + to [[d]
    repeat
  then
;

\ ---[ VLine ]-------------------------------------------------------
\ Draws a vertical line to the dst surface

0 value %vh-bpp

: VLine { *dst _x _y1 _y2 _pixel -- }
  \ Lock the surface if required
  *dst sdl-mustlock if
    *dst sdl-locksurface drop
  then
  \ Calculate the target address of the pixel
  *dst sdl-surface-pixels @     \ *pixels              32-bit pointer
  *dst sdl-surface-pitch sw@    \ *pixels swidth         16-bit value
  _y1 * +                       \ *pixels[swidth*y]
  *dst sdl-surface-format @     \ *pixels[swidth*y] *format
  sdl-pixelformat-bytesperpixel \ *pixels[swidth*y] *format->bytepp
  C@                            \ *pixels[swidth*y] bytepp
  dup to %vh-bpp                \ *pixels[swidth*y] bytepp
  _x * +                        \ *pixels[ofs]
  _y2 _y1 do                    \ *pixels[ofs]
    dup                         \ *ofs *ofs
    _pixel                      \ *ofs *ofs pixel
    %vh-bpp                     \ *ofs *ofs pixel bytepp
    <PlotPixel>                 \ *ofs
    *dst sdl-surface-pitch sw@ + \ *ofs+<pitch>      inc to next line
  loop
  drop
  \ Now unlock the surface if required
  *dst sdl-mustlock if
    *dst sdl-unlocksurface
  then
;

\ The old version of VLine that I am replacing with one that will do
\ all the pixels with the surface being locked/unlocked only once.

: VLine1 { *dst _x _y1 _y2 _pixel -- }
  _y2 _y1 - 0 do
    *dst _x _y1 i + _pixel PutPixel
  loop
;

\ ---[ HLine ]-------------------------------------------------------
\ Draws a horizontal line to the dst surface

: HLine { *dst _x1 _x2 _y _pixel -- }
  \ Lock the surface if required
  *dst sdl-mustlock if
    *dst sdl-locksurface drop
  then
  \ Calculate the target address of the pixel
  *dst sdl-surface-pixels @     \ *pixels              32-bit pointer
  *dst sdl-surface-pitch sw@    \ *pixels swidth         16-bit value
  _y * +                        \ *pixels[swidth*y]
  *dst sdl-surface-format @     \ *pixels[swidth*y] *format
  sdl-pixelformat-bytesperpixel \ *pixels[swidth*y] *format->bytepp
  C@                            \ *pixels[swidth*y] bytepp
  dup to %vh-bpp                \ *pixels[swidth*y] bytepp
  _x1 * +                       \ *pixels[ofs]
  _x2 _x1 do                    \ *pixels[ofs]
    dup                         \ *ofs *ofs
    _pixel                      \ *ofs *ofs pixel
    %vh-bpp                     \ *ofs *ofs pixel bytepp
    <PlotPixel>                 \ *ofs
    %vh-bpp +                   \ *ofs+<pitch>      inc to next pixel
  loop
  drop
  \ Now unlock the surface if required
  *dst sdl-mustlock if
    *dst sdl-unlocksurface
  then
;

\ The old version of HLine that I am replacing with one that will do
\ all the pixels with the surface being locked/unlocked only once.

: HLine1 { *dst _x1 _x2 _y _pixel -- }
  _x2 _x1 - 0 do
    *dst _x1 i + _y _pixel PutPixel
  loop
;

\     -------------
\ ---[ <DrawImage> ]-------------------------------------------------
\     -------------
\ Core routine for both PutImage and PutSprite.
\ By setting the transparency flag <tflag> parameter to 0, the full
\ sprite image, including zeroes, will be plotted.
\ Setting the transparency flag to 1 will cause it to NOT plot the
\ zero pixels, giving the image transparency to the background.
\
\ I should probably get rid of PutSprite, and simply specify that the
\ PutImage function has the transparency flag parameter requirement.
\
\ Change 02/15/2010: 
\ I realized that I do not have to perform a multiply sequence for
\ getting each and every pixel from the sprite image as I have been
\ doing.  It is simpler to set a variable to the start of the image
\ data stream, and increment the pointer as each pixel is accessed.
\
\ ---[ Parameters ]---
\ *dst          - pointer to destination screen surface
\ _x            - top left x coord to display image at
\ _y            - top left y coord to display image at
\ _w            - width of sprite image
\ _h            - height of sprite image
\ *src          - pointer to sprite image data - NOT a screen surface
\ tflag         - transparency flag

0 value %di-ofs

: <Draw-Image> { *dst _x _y _w _h *src tflag -- }
  *src to %di-ofs                           \ initialize data pointer
  _h 0 do
    _w 0 do
      tflag if                               \ transparency flag set?
        %di-ofs C@  0>          \ 0/1           yes - do not plot 0's
      else
        1                       \ 1              no - draw everything
      then
      if                        \                  \ plot if pixel!=0
        *dst _x i + _y j +      \ *dst x+i y+j       \ target x/y set
        %di-ofs C@              \ *dst x+i y+j pixel
        PutPixel                \ --
      then
      %di-ofs 1+ to %di-ofs                  \ increment data pointer
    loop
  loop
;

\     ----------
\ ---[ PutImage ]----------------------------------------------------
\     ----------
\ Draw a bitmap image into the buffer at location x,y.  Every pixel
\ of the image is drawn, so no transparent areas are possible.

: PutImage  ( *dst _x _y _w _h *src -- ) 0 <Draw-Image> ;

\     -----------
\ ---[ PutSprite ]---------------------------------------------------
\     -----------
\ Draw a bitmap image into the buffer at location x,y.
\ Only non-zero pixels are drawn, allowing transparency to the
\ background images which may be present.

: PutSprite  ( *dst _x _y _w _h *src -- ) 1 <Draw-Image> ;

\ Need to add GetSprite (synonym for GetImage, probably)

\ ---[Note]----------------------------------------------------------
\ PutImage and PutSprite will only work correctly with the 8-bit mode
\ of any display resolution.  This is because I have not set the code
\ up to handle color depths larger than one byte.
\ This will need to be addressed.
\ ------------------------------------------------------[End Note]---

